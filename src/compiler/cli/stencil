#!/usr/bin/env node
'use strict';

var fs = require('fs');
var path = require('path');
var chalk = require('./chalk/index.js');

process.title = 'stencil';
process.on('unhandledRejection', function(r) { console.error(r) });
process.env.IONIC_CLI_BIN = __filename;

var versionMatch = process.version.match(/(\d).(\d)/);
if (versionMatch && parseFloat(versionMatch[0]) < 6.4) {
  console.error(chalk.red('ERR: Your Node.js version is ' + chalk.bold(process.version) + '. Please update to the latest Node LTS version.\n'));
  process.exit(1);
}

var cli = require(__dirname, './cli');
var stencil = require(path.join(__dirname, '../dist/compiler'));

var coreClientFileCache = {};

var sys = Object.defineProperties({

  copyDir: function copyDir(src, dest, callback) {
    var fsExtra = require('./fs-extra/index.js');
    fsExtra.copy(src, dest, callback);
  },

  createDom: function createDom() {
    var jsdom = require('jsdom');
    var virtualConsole = new jsdom.VirtualConsole();
    var dom;
    var diagnostics = [];

    virtualConsole.on('jsdomError', function() {
      diagnostics.push({
        level: 'error',
        header: 'DOM Error',
        type: 'hydrate',
        messageText: ([].slice.call(arguments)).join(' ')
      });
    });

    virtualConsole.on('error', function() {
      diagnostics.push({
        level: 'error',
        type: 'hydrate',
        messageText: ([].slice.call(arguments)).join(' ')
      });
    });

    virtualConsole.on('warn', function() {
      diagnostics.push({
        level: 'warn',
        type: 'hydrate',
        messageText: ([].slice.call(arguments)).join(' ')
      });
    });

    return {

      parse: function parse(opts) {
        dom = new jsdom.JSDOM(opts.html, {
          virtualConsole: virtualConsole,
          url: opts.url,
          referrer: opts.referrer,
          userAgent: opts.userAgent
        });

        return dom.window;
      },

      serialize: function serialize() {
        return dom.serialize();
      },

      destroy: function() {
        dom.window.close();
        dom = null;
      },

      getDiagnostics: function() {
        return diagnostics;
      }

    };
  },

  fs: fs,

  generateContentHash: function generateContentHash(content, length) {
    var crypto = require('crypto');
    return crypto.createHash('sha1')
                 .update(content)
                 .digest('base64')
                 .replace(/\W/g, '')
                 .substr(0, length)
                 .toLowerCase();
  },

  getClientCoreFile: function getClientCoreFile(opts) {
    var filePath = path.join(__dirname, '../dist/client', opts.staticName);

    return new Promise(function(resolve, reject) {
      if (coreClientFileCache[filePath]) {
        resolve(coreClientFileCache[filePath]);

      } else {
        fs.readFile(filePath, 'utf-8', function(err, data) {
          if (err) {
            reject(err);
          } else {
            coreClientFileCache[filePath] = data;
            resolve(data);
          }
        });
      }
    });
  },

  minifyCss: function minifyCss(input) {
    var CleanCSS = require('./clean-css/index.js');
    var result = new CleanCSS().minify(input);
    var diagnostics = [];

    if (result.errors) {
      result.errors.forEach(function(msg) {
        diagnostics.push({
          messageText: msg,
          level: 'error'
        });
      });
    }

    if (result.warnings) {
      result.warnings.forEach(function(msg) {
        diagnostics.push({
          messageText: msg,
          level: 'warn'
        });
      });
    }

    return {
      output: result.styles,
      sourceMap: result.sourceMap,
      diagnostics: diagnostics
    };
  },

  minifyJs: function minifyJs(input) {
    var UglifyJS = require('./uglify-es/tools/node.js');
    var result = UglifyJS.minify(input);
    var diagnostics = [];

    if (result.error) {
      diagnostics.push({
        messageText: result.error.message,
        level: 'error'
      });
    }

    return {
      output: result.code,
      sourceMap: result.sourceMap,
      diagnostics: diagnostics
    };
  },

  path: path,

  resolveModule: function resolveModule(fromDir, moduleId) {
    fromDir = path.resolve(fromDir);
    var fromFile = path.join(fromDir, 'noop.js');

    return module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: module._nodeModulePaths(fromDir)
    });
  },

  rmDir: function rmDir(dir, callback) {
    var fsExtra = require('./fs-extra/index.js');
    fsExtra.remove(dir, callback);
  },

  vm: {
    createContext: function(sandbox) {
      var vm = require('vm');
      // https://github.com/tmpvar/jsdom/issues/1724
      // manually adding a fetch polyfill until jsdom adds it
      sandbox.fetch = require('./node-fetch/index.js');
      return vm.createContext(sandbox);
    },
    runInContext: function(code, contextifiedSandbox, options) {
      var vm = require('vm');
      vm.runInContext(code, contextifiedSandbox, options);
    }
  },

  watch: function watch(paths, opts) {
    var chokidar = require('./chokidar/index.js');
    return chokidar.watch(paths, opts);
  }

}, {
  // sys on-demand getters
  rollup: {
    get: function() {
      var rollup = require('./rollup/dist/rollup.js');
      rollup.plugins = {
        commonjs: require('./rollup-plugin-commonjs/dist/rollup-plugin-commonjs.cjs.js'),
        nodeResolve: require('./rollup-plugin-node-resolve/dist/rollup-plugin-node-resolve.cjs.js')
      };
      return rollup;
    }
  },

  sass: {
    get: function() {
      return require('node-sass');
    }
  },

  typescript: {
    get: function() {
      return require('typescript');
    }
  },

});


cli.run(process, sys, chalk, stencil);
